use crate::Bits;

const 

/// Compute the phase change for a sequence of bits.
fn phase_change_for_bits(for_bits: &Bits) -> i32 {

    if for_bits.len() % 2 == 0 {
        panic!("phase_change_for_bits requires an odd number of bits, got {}", for_bits.len());
    }

    let mut phase_change = 0;

    // Iterate over pairs of bits
    for i in (0..for_bits.len()).step_by(2) {

        // Calculate the phase change for the pair of bits
        phase_change += match (for_bits[i], for_bits[i + 1]) {
            (false, false) => 1,   // 00 -> +1 π/4
            (false, true)  => 3,   // 01 -> +3 π/4
            (true, false)  => -1,  // 10 -> -1 π/4
            (true, true)   => -3,  // 11 -> -3 π/4
        };

    }

    phase_change
}

/// Calculates the phase adjustment bits within burst structures.
///
/// Phase change is always calculated over an odd number of symbols, therefore the phase change of
/// a given sequence will always be odd (each symbol generates either +1, +3, -1 or -3 π/4 offset).
///
/// The phase adjustment bits are set such that their own phase change equals the inverse of the sum
/// of the phase change generated by the defined sequence.
///
/// For example if a defined sequence of symbols has a total phase change of +5 π/4 the bits must
/// generate a phase change of +3 π/4 to leave a 0 phase change.
pub fn phase_adjustment_bits(for_bits: &Bits) -> (bool, bool) {

    // Phase adjustment not possible on odd-length bit sequences
    if for_bits.len() % 2 != 0 {
        panic!("phase adjustment not possible on odd-length bit sequences, got {} bits", for_bits.len());
    }

    // Phase adjustment is only possible on odd *symbol* sequences
    if for_bits.len() % 4 == 0 {
        panic!("phase adjustment not possible on even-length symbol sequences, got {} bits", for_bits.len());
    }

    // Compute the phase change for the given bits
    let mut phase_shift = phase_change_for_bits(for_bits);

    // We want to *correct* for this phase shift, so we're looking for the difference
    phase_shift *= -1;

    // Wrap-around on the imaginary axis
    // This ensures we'll always apply a correction between -3 and +3 π/4
    if phase_shift > 3 {
        phase_shift -= 8;
    } else if phase_shift < -3 {
        phase_shift += 8;
    }

    // Convert the phase shift to bits
    match phase_shift {
        3 => (false, true),  // +3 π/4
        1 => (false, false), // +1 π/4
        -1 => (true, false), // -1 π/4
        -3 => (true, true),  // -3 π/4
        _ => panic!("not possible to produce phase adjustment for correction: {}", phase_shift),
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use crate::Bits;
    use bitvec::prelude::*;

    #[test]
    #[should_panic]
    fn calculate_phase_rejects_odd_length_bits() {
        let bits = Bits::from_bitslice(bits![u8, Msb0; 0, 1, 0]);
        phase_change_for_bits(&bits);
    }

    #[test]
    #[should_panic]
    fn adjustment_calculation_rejects_even_length_symbols() {
        let bits = Bits::from_bitslice(bits![u8, Msb0; 0, 1, 0, 0, 1, 1, 0, 1]);
        phase_adjustment_bits(&bits);
    }


}