use bitvec::slice::BitSlice;
use crate::bits::Bits;

/// Define the boundary positions for phase sum calculations
/// Note that these are symbol numbers (SNs), not bit numbers (BNs)
/// EN 300 392-2 § 9.4.4.3.6 Table 9.15
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HA: (usize, usize) = (8, 122);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HB: (usize, usize) = (123, 249);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HC: (usize, usize) = (8, 108);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HD: (usize, usize) = (109, 249);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HE: (usize, usize) = (112, 230);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HF: (usize, usize) = (1, 111);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HG: (usize, usize) = (3, 117);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HH: (usize, usize) = (118, 244);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HI: (usize, usize) = (3, 103);
pub const PHASE_ADJUSTMENT_SYMBOL_RANGE_HJ: (usize, usize) = (104, 244);

/// Extract a range of bits based on a symbol number range
/// NOTE that it assumed start_sn & end_sn are 1-based as per EN 300 392
pub(crate) fn extract_sn_range_bits(bits: &Bits, start_sn: usize, end_sn: usize) -> Bits
{
    let start_bn = (start_sn - 1) * 2;
    let end_bn = (end_sn) * 2;
    Bits::from_bitslice(&bits[start_bn .. end_bn])
}

/// Compute the phase change in multiples of π/4 for a sequence of bits.
fn phase_change_for_bits<O ,T>(for_bits: &BitSlice<T, O>) -> i32 where
    O: bitvec::order::BitOrder,
    T: bitvec::store::BitStore
{
    if for_bits.len() % 2 != 0 {
        panic!("phase_change_for_bits requires an even number of bits, got {}", for_bits.len());
    }

    let mut phase_change = 0;

    // Iterate over pairs of bits
    for i in (0..for_bits.len()).step_by(2) {

        // Calculate the phase change for the pair of bits
        phase_change += match (for_bits[i], for_bits[i + 1]) {
            (false, false) => 1,   // 00 -> +1 π/4
            (false, true)  => 3,   // 01 -> +3 π/4
            (true, false)  => -1,  // 10 -> -1 π/4
            (true, true)   => -3,  // 11 -> -3 π/4
        };

    }

    phase_change % 8
}

/// Calculates the phase adjustment bits within burst structures.
///
/// Phase change is always calculated over an odd number of symbols, therefore the phase change of
/// a given sequence will always be odd (each symbol generates either +1, +3, -1 or -3 π/4 offset).
///
/// The phase adjustment bits are set such that their own phase change equals the inverse of the sum
/// of the phase change generated by the defined sequence.
///
/// For example if a defined sequence of symbols has a total phase change of +5 π/4 the bits must
/// generate a phase change of +3 π/4 to leave a 0 phase change.
pub fn phase_adjustment_bits<O, T>(for_bits: &BitSlice<T, O>) -> [bool; 2] where
    T: bitvec::store::BitStore,
    O: bitvec::order::BitOrder
{

    // Phase adjustment not possible on odd-length bit sequences
    if for_bits.len() % 2 != 0 {
        panic!("phase adjustment not possible on odd-length bit sequences, got {} bits", for_bits.len());
    }

    // Phase adjustment is only possible on odd *symbol* sequences
    if for_bits.len() / 2 % 2 == 0 {
        panic!("phase adjustment not possible on even-length symbol sequences, got {} bits", for_bits.len());
    }

    // Compute the phase change for the given bits
    let mut phase_shift = phase_change_for_bits(for_bits);

    // We want to *correct* for this phase shift, so we're looking for the difference
    phase_shift *= -1;

    // Wrap-around on the imaginary axis
    // This ensures we'll always apply a correction between -3 and +3 π/4
    if phase_shift > 3 {
        phase_shift -= 8;
    } else if phase_shift < -3 {
        phase_shift += 8;
    }

    // Convert the phase shift to bits
    match phase_shift {
        3 => [false, true],  // +3 π/4
        1 => [false, false], // +1 π/4
        -1 => [true, false], // -1 π/4
        -3 => [true, true],  // -3 π/4
        _ => panic!("not possible to produce phase adjustment for correction: {phase_shift}"),
    }
}

#[cfg(test)]
mod tests {

    use super::*;
    use bitvec::prelude::*;

    #[test]
    #[should_panic]
    fn calculate_phase_rejects_odd_length_bits() {
        let bits = bits![0, 1, 0];
        phase_change_for_bits(bits);
    }

    #[test]
    #[should_panic]
    fn adjustment_calculation_rejects_even_length_symbols() {
        let bits = bits![0, 1, 0, 0, 1, 1, 0, 1];
        phase_adjustment_bits(bits);
    }

    #[test]
    fn calculates_total_correctly() {

        // Simple, 00 advances 1/4π
        assert_eq!(phase_change_for_bits(bits![0, 0, 0, 0, 0, 0, 0, 0]), 4);

        // Wrapping
        assert_eq!(phase_change_for_bits(bits![
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0
        ]), 0);

        assert_eq!(phase_change_for_bits(bits![
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0,
            0, 1
        ]), 3);

        // 10 advances -1/4π
        assert_eq!(phase_change_for_bits(bits![0, 0, 0, 0, 0, 0, 1, 0]), 2);

        // 01 advances 3/4π
        assert_eq!(phase_change_for_bits(bits![0, 0, 0, 0, 0, 0, 0, 1]), 6);

        // 11 advances -3/4π
        assert_eq!(phase_change_for_bits(bits![0, 0, 0, 0, 0, 0, 1, 1]), 0);

        // Example from "Digital Mobile Communications and the TETRA System" pg 218
        assert_eq!(phase_change_for_bits(bits![0, 1, 1, 0, 0, 1, 0, 0]), 6);
    }

    #[test]
    fn generates_correct_bits()
    {
        // Calculated by-hand, 7 zero symbols (+7pi/4) should need one more to correct phase to 0
        assert_eq!(
            phase_adjustment_bits(bits![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
            [false, false]
        );

        // Wrapping around to +3/-3 (+5π/4)
        assert_eq!(
            phase_adjustment_bits(bits![0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
            [false, true]
        );
    }

}